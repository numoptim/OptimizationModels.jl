var documenterSearchIndex = {"docs":
[{"location":"api_counters/#Counters","page":"Counters","title":"Counters","text":"","category":"section"},{"location":"api_counters/","page":"Counters","title":"Counters","text":"Counter","category":"page"},{"location":"api_counters/#OptimizationModels.Counter","page":"Counters","title":"OptimizationModels.Counter","text":"Counter\n\nA counter for partial evaluations of typical quantities used in solving      optimization problems. These counters can be used in a      number of contexts:\n\nBlock Selection: For evaluations of objective information    (e.g., objective functions, gradient functions, etc.) that only make use    of a subset of the parameters.  \nBatch Selection: For evaluations of objective information   (e.g., objective fucntions, gradient functions, etc.) that is written    as the sum of multiple components, but only a subset of the components    are used. \nBlock and Batch Selection: Simultaneously doing both of the above situations.\n\nFields\n\nblock_total::Int64, the number of parameters\nbatch_total::Int64, the number of additive terms in the objective function \nblock_equivalent::Float64, the equivalent number of batch_total evaluations    given a certain number of coordinate evaluations  \nbatch_equivalent::Float64, the equivalent number of block_total evaluations    given evaluations of objective information using only a subset of the   additive terms.  \n\nConstructor(s)\n\nCounter(;block_total::Int64=1, batch_total::Int64=1)\n\nCreates a Counter object with block_equivalent and batch_equivalent      set to zero. The optional block_total and batch_total are set to 1.\n\n\n\n\n\n","category":"type"},{"location":"api_counters/#Incrementing-Counters","page":"Counters","title":"Incrementing Counters","text":"","category":"section"},{"location":"api_counters/","page":"Counters","title":"Counters","text":"increment_block!\n\nincrement_batch!\n\nincrement!","category":"page"},{"location":"api_counters/#OptimizationModels.increment_block!","page":"Counters","title":"OptimizationModels.increment_block!","text":"increment_block!(counter::Counter; size::Int64=1)\n\nIncrements the counter.block_equivalent by size/counter.block_equivalent.\n\n\n\n\n\n","category":"function"},{"location":"api_counters/#OptimizationModels.increment_batch!","page":"Counters","title":"OptimizationModels.increment_batch!","text":"increment_batch!(counter::Counter; size::Int64=1)\n\nIncrements the counter.batch_equivalent by size/counter.batch_equivalent.\n\n\n\n\n\n","category":"function"},{"location":"api_counters/#OptimizationModels.increment!","page":"Counters","title":"OptimizationModels.increment!","text":"increment!(counter::Counter; batch_size::Int64=0, block_size::Int64=0)\n\nIncrements the counter.block_equivalent and counter.batch_equivalent by      block_size/counter.block_total and batch_size/counter.batch_total.\n\n\n\n\n\n","category":"function"},{"location":"api_counters/#Resetting-Counters","page":"Counters","title":"Resetting Counters","text":"","category":"section"},{"location":"api_counters/","page":"Counters","title":"Counters","text":"reset_block!\n\nreset_batch!\n\nreset!","category":"page"},{"location":"api_counters/#OptimizationModels.reset_block!","page":"Counters","title":"OptimizationModels.reset_block!","text":"reset_block!(counter::Counter)\n\nResets the counter.block_equivalent to 0.0.\n\n\n\n\n\n","category":"function"},{"location":"api_counters/#OptimizationModels.reset_batch!","page":"Counters","title":"OptimizationModels.reset_batch!","text":"reset_batch!(counter::Counter)\n\nResets the counter.batch_equivalent to 0.0.\n\n\n\n\n\n","category":"function"},{"location":"api_counters/#OptimizationModels.reset!","page":"Counters","title":"OptimizationModels.reset!","text":"reset!(counter::Counter)\n\nResets the counter.block_equivalent and counter.batch_equivalent to 0.\n\n\n\n\n\n","category":"function"},{"location":"api_counters/#Validating-Counters","page":"Counters","title":"Validating Counters","text":"","category":"section"},{"location":"api_counters/","page":"Counters","title":"Counters","text":"Allowed counters are defined within the module as an element of ","category":"page"},{"location":"api_counters/","page":"Counters","title":"Counters","text":"[\n    :obj, \n    :grad, \n    :hess, \n    :residual,\n    :jacobian,\n]","category":"page"},{"location":"api_counters/","page":"Counters","title":"Counters","text":"The following function can be used to validate a dictionary of counters.","category":"page"},{"location":"api_counters/","page":"Counters","title":"Counters","text":"validate_counters","category":"page"},{"location":"api_counters/#OptimizationModels.validate_counters","page":"Counters","title":"OptimizationModels.validate_counters","text":"validate_counters(counters::Dict{Symbol, Counter})\n\nValidates that counter names are in the allowable list. Throws an error if     the list is invalid. Returns nothing if valid. \n\n\n\n\n\n","category":"function"},{"location":"api_counters/#Printing","page":"Counters","title":"Printing","text":"","category":"section"},{"location":"api_counters/","page":"Counters","title":"Counters","text":"Counters and dictionaries of counters can be printed using the print  or println functions. ","category":"page"},{"location":"api_validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"api_validation/","page":"Validation","title":"Validation","text":"Minimum required field names and types are","category":"page"},{"location":"api_validation/","page":"Validation","title":"Validation","text":"[\n    :name => String,\n    :counters => Dict{Symbol, Counter},\n    :num_param => Int64,\n    :num_obs => Int64\n]","category":"page"},{"location":"api_validation/","page":"Validation","title":"Validation","text":"The following utilities are exported.","category":"page"},{"location":"api_validation/","page":"Validation","title":"Validation","text":"validate ","category":"page"},{"location":"api_validation/#OptimizationModels.validate","page":"Validation","title":"OptimizationModels.validate","text":"validate(type)\n\nChecks if the supertype of type and fields of type are in accordance with     the requirements of the model interface needed by OptimizationProblem.\n\n\n\n\n\n","category":"function"},{"location":"api_validation/","page":"Validation","title":"Validation","text":"Additional utilities are available within the scope of the module.","category":"page"},{"location":"api_validation/","page":"Validation","title":"Validation","text":"OptimizationModels.validate_supertype\n\nOptimizationModels.validate_fields","category":"page"},{"location":"api_validation/#OptimizationModels.validate_supertype","page":"Validation","title":"OptimizationModels.validate_supertype","text":"validate_supertype(type)\n\nThrows an error if supertype of type is not OptimizationProblem.     Otherwise, returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api_validation/#OptimizationModels.validate_fields","page":"Validation","title":"OptimizationModels.validate_fields","text":"validate_fields(type)\n\nChecks if the minimum field requirements of type and their types are      correctly specified. If not, then an ErrorException is thrown.      Otherwise, returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"OptimizationModels.jl is a research-tier software package for the Julia language that provides a uniform interface for modeling optimization problems arising in data science. OptimizationModels.jl is heavily influenced by the design of NLPModels.jl, which may be more appropriate for traditional optimization problems, especially those with constraints. ","category":"page"},{"location":"#Types-of-Problems","page":"Overview","title":"Types of Problems","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The library focuses on objective functions of the form","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"F(x) = sum_i=1^n f_i(x)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where FmathbbR^p to mathbbR is the objective function; f_imathbbR^p to mathbbR are component functions for i=1ldotsn. This formulation requires accounting for optimization methods that solve ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"min_x F(x)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Use a subset of the component functions (which we call a batch).\nUse a subset of the coordinates (which we call a block).\nUse both a subset of the component functions and coordinates.","category":"page"},{"location":"#Encapsulating-Problems","page":"Overview","title":"Encapsulating Problems","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"An optimization problem must be a struct whose parent is of type OptimizationProblem, which is an abstract type provided by this package.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"OptimizationProblem","category":"page"},{"location":"#OptimizationModels.OptimizationProblem","page":"Overview","title":"OptimizationModels.OptimizationProblem","text":"abstract type OptimizationProblem end\n\nAn abstract type for optimization problems.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Overview","title":"Overview","text":"Any child of OptimizationProblem are required to have four fields (see Validation Utilities section).","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"name::String, which provides a name to identify the problem.\ncounters::Dict{Symbol, Counter}, which contains the counters for tracking    objective information evaluations (see the Counters section).\nnum_params::Int64, the number of parameters to be optimized over.\nnum_obs::Int64, the number of component functions.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Other fields that are specific to the problem are allowed, and, in total, these fields, when instantiated, must identify a unique optimization problem. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Let ExampleProblem be a child of OptimizationProblem with the appropriate fields. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Then ExampleProblem should implement the following methods with the  given arguments.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"obj(x::Vector; problem::ExampleProblem, store::Dict{Symbol, Array},   batch::AbstractVector{Int64}), which evaluates the objective function at x. The pairs in store are used to reduce memory overhead. The elements   of batch specify the indices of the component function used in calculating   the objective function.\ngrad!(x::Vector; problem::ExampleProblem, store::Dict{Symbol, Array},   batch::AbstractVector{Int64}, block::AbstractVector{Int64}),    which evaluates the gradient function at x at the coordinates specified    by the indices in block, and using the component functions whose indices   are specified in batch. The pairs in store must have one that   corresponds to :grad, where the result of the calculation will be stored.   The function should return nothing. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If needed, the functions hess!, jacobian! and residual! should be implemented in a fashion similar to grad!. ","category":"page"},{"location":"#Counters","page":"Overview","title":"Counters","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"A counter tracks the number of evaluations of a specific type of objective information. Possible objective information includes  objective function evaluations, gradient function evaluations,  Hessian evaluations, residual evaluations (for generalizations of least squares problems), and Jacobian evaluations (for generalized of least squares problems).","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"To account for the possibility of using batches and/or blocks, a counter for  keeps track of the equivalent number of full evaluations for both batches  and blocks. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For instance, if the batch f_i_1ldotsf_i_j is used for evaluating  the objective function, then the objective evaluation batch counter will be  incremented by jn. As another example, if only x_k_1ldotsx_k_ell are evaluated for  the gradient function, then the gradient evaluation block counter will be incremented by ellp. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Counters must be stored in a dictionary, Dict{Symbol, Counter}, where the  first argument of a dictionary entry corresponds to the objective information being tracked. Allowed values are  :obj, :grad, :hess, :residual, and :jacobian.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The functions print and println are extended for Counter objects and  for Dict{Symbol, Counter}. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A function, validate_counters(counters::Dict{Symbol, Counter}) is provided  to enforce that only above allowed values are used in specifying the dictionary. If nothing is returned, then the counters are valid.","category":"page"},{"location":"#Validation-Utility","page":"Overview","title":"Validation Utility","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"A function validate is provided to ensure that a struct whose parent is  OptimizationProblem has the appropriate super type, minimum field names, and  corresponding types for these fields. If nothing is returned, then the struct is valid. ","category":"page"}]
}
